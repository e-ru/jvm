import org.eclipse.jdt.core.formatter.CodeFormatter;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

buildscript {
	repositories {
		jcenter()
		maven {
			url 'https://plugins.gradle.org/m2/'
		}
	}
	dependencies {
		classpath 'org.eclipse.jdt:org.eclipse.jdt.core:3.12.2'
	}
}

plugins {
	id 'com.github.spotbugs' version '2.0.0'
}

configure(subprojects) {
	apply plugin: 'java'
	apply plugin: 'checkstyle'
	apply plugin: 'eclipse'
	apply plugin: 'com.github.spotbugs'

	checkstyle {
		toolVersion '8.20'
		configDir file("$rootProject.projectDir/config/checkstyle")
	}

	spotbugs {
		toolVersion = '3.1.12'
		sourceSets = [sourceSets.main]
		ignoreFailures = true
		reportsDir = file("$project.buildDir/findbugsReports")
		effort = 'max'
		reportLevel = 'high'
		visitors = [
			'FindSqlInjection',
			'SwitchFallthrough'
		]
		omitVisitors = ['FindNonShortCircuit']
		//		includeFilter = file("$rootProject.projectDir/config/findbugs/includeFilter.xml")
		excludeFilter = file("$rootProject.projectDir/config/findbugs/excludeFilter.xml")
	}

	tasks.withType(com.github.spotbugs.SpotBugsTask) {
		reports {
			xml.enabled = false
			html.enabled = true
		}
	}

	eclipse {
		classpath {
			downloadSources=true
		}
		jdt.file.withProperties {
			it['org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable'] = 'ignore'
			it['org.eclipse.jdt.core.compiler.problem.missingSerialVersion'] = 'ignore'
			it['org.eclipse.jdt.core.compiler.problem.unhandledWarningToken'] = 'ignore'
			it['org.eclipse.jdt.core.formatter.use_on_off_tags'] = 'true'
			it['org.eclipse.jdt.core.formatter.lineSplit'] = '120'
			it['org.eclipse.jdt.core.formatter.comment.line_length'] = '120'
			it['org.eclipse.jdt.core.formatter.join_wrapped_lines'] = 'false'
			it['org.eclipse.jdt.core.formatter.join_lines_in_comments'] = 'false'
			it['org.eclipse.jdt.core.formatter.comment.align_tags_descriptions_grouped'] = 'true'
			it['org.eclipse.jdt.core.compiler.problem.forbiddenReference'] = 'info'
			//			it['sp_cleanup.organize_imports'] = 'true'
			//			it['sp_cleanup.format_source_code'] = 'true'
			//			it['sp_cleanup.format_source_code_changes_only'] = 'false'
		}
	}

	eclipseJdt.doLast {
		File f = file('.settings/org.eclipse.core.resources.prefs')
		f.write('eclipse.preferences.version=1\n')
		f.append('encoding/<project>=UTF-8')
	}

	test {
		useJUnitPlatform()
	}
}

subprojects {
	sourceCompatibility = 11
	targetCompatibility = 11

	task javaFormat(dependsOn: 'eclipse') {
		doLast {
			FileTree tree = fileTree(dir: 'src/main/java')
			tree.include '**/*.java'
			tree.each{File f -> formatJavaFile(f)}
		}

		task allDeps(type: DependencyReportTask) {}
	}

	repositories {
		jcenter()
		maven { url "https://repo1.maven.org/maven2" }
	}
}

def formatJavaFile(File f) {
	Map options = DefaultCodeFormatterConstants.getEclipseDefaultSettings();
	options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_8);
	options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_8);
	options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_8);
	Properties props = new Properties();
	props.load(new FileInputStream('.settings/org.eclipse.jdt.core.prefs'));
	for(Map.Entry<Object, Object> e : props.entrySet()) {
		options.put(e.getKey(), e.getValue());
	}

	def code = f.text;
	CodeFormatter cf = ToolFactory.createCodeFormatter(options);
	TextEdit te = cf.format(CodeFormatter.K_UNKNOWN, code, 0, code.length(), 0,
			System.getProperty("line.separator"));
	IDocument dc = new Document(code.toString());
	if (te == null || code.length() == 0) {
		System.err.println("!!! Could not format " + f + " !!!");
	} else {
		if(te.getChildrenSize() > 0) {
			println "FORMAT "+f
		}
		te.apply(dc);
		f.write(dc.get());
	}
}
