import org.eclipse.jdt.core.formatter.CodeFormatter;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

buildscript {
	repositories {
	  jcenter()
	  maven {
			url "https://plugins.gradle.org/m2/"
		  }
	}
	dependencies {
	  classpath 'org.eclipse.jdt:org.eclipse.jdt.core:3.12.2'
	}
}


plugins {
	id "com.diffplug.gradle.spotless" version "3.23.0" apply false
}

subprojects {

	repositories {
		// Use jcenter for resolving your dependencies.
		// You can declare any Maven/Ivy/file repository here.
		jcenter()
	}

	apply plugin: 'java'
	apply plugin: "com.diffplug.gradle.spotless"
	apply plugin: 'checkstyle'
	apply plugin: 'eclipse'

	spotless {
		java {
			licenseHeader '/* Licensed under Apache-2.0 */'	// License header
			//licenseHeaderFile 'spotless.license.java'		// License header file

			importOrderFile '../config/spotless.importorder' // An import ordering file, exported from Eclipse

			removeUnusedImports() // removes any unused imports

			eclipse().configFile '../config/spotless.xml'	// XML file dumped out by the Eclipse formatter
		}
	}

	checkstyle {
		toolVersion '8.20'
		configDir file("$rootProject.projectDir/config/checkstyle")
	}

	configure(subprojects) {
		checkstyleMain {
			source ='src/main/java'
		}
		checkstyleTest {
			source ='src/test/java'
		}
		spotbugs {
			toolVersion = '3.1.12'
			sourceSets = [sourceSets.main]
			ignoreFailures = true
			reportsDir = file("$project.buildDir/findbugsReports")
			effort = "max"
			reportLevel = "high"
			visitors = [
				"FindSqlInjection",
				"SwitchFallthrough"
			]
			omitVisitors = ["FindNonShortCircuit"]
			includeFilter = file("$rootProject.projectDir/config/findbugs/includeFilter.xml")
			excludeFilter = file("$rootProject.projectDir/config/findbugs/excludeFilter.xml")
		}

		eclipse {
			classpath {
				downloadSources=true
			}
			jdt.file.withProperties {
				it['org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable'] = 'ignore'
				it['org.eclipse.jdt.core.compiler.problem.missingSerialVersion'] = 'ignore'
				it['org.eclipse.jdt.core.compiler.problem.unhandledWarningToken'] = 'ignore'
				it['org.eclipse.jdt.core.formatter.use_on_off_tags'] = 'true'
				it['org.eclipse.jdt.core.formatter.lineSplit'] = '120'
				it['org.eclipse.jdt.core.formatter.comment.line_length'] = '120'
				it['org.eclipse.jdt.core.formatter.join_wrapped_lines'] = 'false'
				it['org.eclipse.jdt.core.formatter.join_lines_in_comments'] = 'false'
				it['org.eclipse.jdt.core.formatter.comment.align_tags_descriptions_grouped'] = 'true'
				it['org.eclipse.jdt.core.compiler.problem.forbiddenReference'] = 'info'
			}
		}

		eclipseJdt.doLast {
			File f = file('.settings/org.eclipse.core.resources.prefs')
			f.write('eclipse.preferences.version=1\n')
			f.append('encoding/<project>=UTF-8')
		}

		dependencies {
			spotbugsPlugins 'com.h3xstream.findsecbugs:findsecbugs-plugin:1.7.1'
		}
	}

	task javaFormat(dependsOn: 'eclipse') {
		doLast {
			FileTree tree = fileTree(dir: 'src/main/java')
			tree.include '**/*.java'
			tree.each{File f -> formatJavaFile(f)}
		}

		task allDeps(type: DependencyReportTask) {}
	}
}

def formatJavaFile(File f) {
	Map options = DefaultCodeFormatterConstants.getEclipseDefaultSettings();
	options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_8);
	options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, JavaCore.VERSION_1_8);
	options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_8);
	Properties props = new Properties();
	props.load(new FileInputStream(".settings/org.eclipse.jdt.core.prefs"));
	for(Map.Entry<Object, Object> e : props.entrySet()) {
		options.put(e.getKey(), e.getValue());
	}

	def code = f.text;
	CodeFormatter cf = ToolFactory.createCodeFormatter(options);
	TextEdit te = cf.format(CodeFormatter.K_UNKNOWN, code, 0, code.length(), 0,
			System.getProperty("line.separator"));
	IDocument dc = new Document(code.toString());
	if (te == null || code.length() == 0) {
		System.err.println("!!! Could not format " + f + " !!!");
	} else {
		if(te.getChildrenSize() > 0) {
			println "FORMAT "+f
		}
		te.apply(dc);
		f.write(dc.get());
	}
}
